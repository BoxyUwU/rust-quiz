# Construction Site @adotinthevoid @jdonszelmann @Victoronz @GoldsteinE @WaffleLapkin @BoxyUwU

```rust
// 1.
{{#include ../../code/examples/misc_9_1.rs:matters}}
```
```rust
// 2.
{{#include ../../code/examples/misc_9_2.rs:matters}}
```

<details>
<summary>Solution</summary>

There are 3 kinds of structs in Rust:

1. Plain structs (eg `struct Foo { bar: i32 }`)
2. Tuple structs (eg `struct Bar(i32);`)
3. Unit structs (eg `struct Baz;`)

The name of a plain struct refers to the *type* of the struct.

The name of a tuple struct either refers to the *type* of the struct or the implicit *function* used to construct it:
```rust
struct Tuple(u32);

// conceptually desugars to...
struct Tuple { 0: u32 }
fn Tuple(0: u32) -> Tuple { /* not important */ }
```

The name of a unit struct either refers to the *type* of the struct or the implicit *constant* representing its only value.
```rust
struct Tuple;

// conceptually desugars to...
struct Tuple { }
const Tuple: Tuple = /* not important */;
```

---

```
// 1.
{{#include ../../code/examples/stderr/misc_9_1.stderr}}
```

In the first example both `Unit` and `Tuple` are valid expressions, evaluating to either the only value of the `Unit` type or the function item for the constructor of `Tuple`.

`Struct` however is not a valid expression as it simply refers to the type of the struct.


```
// 2.
{{#include ../../code/examples/stderr/misc_9_2.stderr}}
```

In the second example, perhaps surprisingly, all of `Unit {}`, `Tuple { 0: 1_u32 }` and `Struct {}` are valid.
Both tuple and unit structs both support `Struct {}` syntax as it is useful for macros.

---

Another interesting example would be the interactions between `Unit`'s constant and destructuring assignment:
```rust
// 3.
{{#include ../../code/examples/misc_9_3.rs:matters}}

{{#include ../../code/examples/stderr/misc_9_3.stderr}}
```

`Unit` is a valid pattern as it actually refers to the *constant* representing the only value of the unit struct.

`Tuple` and `Struct` however are not valid patterns as they are a path to a function and a path to a type.

</details>
