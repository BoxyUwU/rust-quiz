# A Whole Wide Universe @WaffleLapkin @BoxyUwU

```rust
{{#include ../../code/examples/borrowck_2.rs}}
```

<details>
<summary>Solution</summary>

```
{{#include ../../code/examples/stderr/borrowck_2.stderr}}
```

In order for this code to compile the type parameter `R` on `consume_fn` must be able to be given a type argument of `&'b u32` by the caller in `main`.

The type `&'b u32` mentions a higher-ranked lifetime `'b` from the `for`-all `for<'b>`.
Only types *inside* of the `for`-all can name lifetimes introduced by the `for`-all.

If the compiler allowed this we would wind up with a function call that looks something like: `consume_fn::<&'b u32, for<'b> fn(&'b u32) -> &'b u32>(...)`.

This would be quite incoherent as the lifetime `'b` can be chosen to be a different lifetime by every caller of `fnptr`.
There's no way to know what `&'b u32` actually *means* outside of the `for<'b>`. 

This concept is very closely related to *existential* and *universal* quantifiers in formal logic.
`exists<T> forall<U> T == U` cannot be proven, however `forall<U> exists<T> T == U` *can*.

In Rust terms this roughly corresponds to inferences variables being *existential* quantifiers, and `for<...>` in types as being *universal* quantifiers.
Though, it's worth noting that in some cases `for<...>` in types is actually treated as an *existential* quantifier.

</details>
